|{0}th{0}e quick brown fox

//== 0 > 1
//= dance.select.word.previous
// No more selections remaining, just keep the last one.
|{0}th{0}e quick brown fox

//== 0 > 2
//= dance.count.4
//= dance.select.word
the quick brown {0}fox|{0}

//== 2 > 3
//= dance.select.word
// No more selections remaining, just keep the last one.
the quick brown {0}fox|{0}

//== 3 > 3.repeat
//= dance.select.word
// No more selections remaining, do not change.
the quick brown {0}fox|{0}

//== 0 > 4
//= dance.count.5
//= dance.select.word
// Move 4 times, but don't move again (no more selections remaining otherwise).
the quick brown {0}fox|{0}

//== 2 > 5
//= dance.count.4
//= dance.select.word.previous
|{0}the {0}quick brown fox

//== 2 > 6
//= dance.count.5
//= dance.select.word.previous
// Move 4 times, but don't move again (no more selections remaining otherwise).
|{0}the {0}quick brown fox

//== 100
foo bar{0}
|{0}baz

//== 100 > 101
//= dance.select.word.previous
foo |{0}bar{0}
baz

//== multi.0
|{0}the {0}qu|{1}ic{1}k brown fox

//== multi.0 > multi.1
//= dance.select.word.previous
// Old Selection 0 overflowed and was removed. Old Selection 1 moved.
the |{0}qui{0}ck brown fox

//== multi.0 > multi.2
//= dance.count.9
//= dance.select.word.previous
// Both overflowed and both falled back to the selection below.
// VSCode will then automatically merge the two selections since they overlap.
|{0}|{1}the {0}{1}quick brown fox

//== multi.0 > multi.3
//= dance.count.4
//= dance.select.word.end
// Old Selection 1 overflowed and was removed. Old Selection 0 moved.
the quick brown{0} fox|{0}

//== multi.0 > multi.4
//= dance.count.5
//= dance.select.word.end
// Both overflowed and both falled back to the selection below.
// VSCode will then automatically merge the two selections since they overlap.
the quick brown{0}{1} fox|{0}|{1}

//== blank.start.0

|{0}there{0} is a blank line before me

//== blank.start.0 > blank.start.1
//= dance.select.word.previous
// Special case in Kak: anchor is moved to beginning of document and active is
// moved to the first character of the second line.
{0}
t|{0}here is a blank line before me

//== blank.start.1 > blank.start.2
//= dance.select.word.previous
// Going to previous again will just keep the selection the same.
{0}
t|{0}here is a blank line before me

//== blank.start.0 > blank.start.3
//= dance.count.9
//= dance.select.word.previous
// Similarly, more repetitions won't do anything either.
{0}
t|{0}here is a blank line before me

//== blank.start.4


|{0}there{0} are two blank lines before me

//== blank.start.4 > blank.start.5
//= dance.select.word.previous
// Special case in Kak: anchor is moved to beginning of document and active is
// moved to the first character (line break in this case) of the second line.
{0}

|{0}there are two blank lines before me

//== blank.start.5 > blank.start.6
//= dance.select.word.previous
// Going to previous again will just keep the selection the same.
{0}

|{0}there are two blank lines before me

//== blank.start.4 > blank.start.7
//= dance.count.9
//= dance.select.word.previous
// Similarly, more repetitions won't do anything either.
{0}

|{0}there are two blank lines before me

// TODO: Write tests for blank lines in the end.
// But how? Currently, trailing blank lines in test cases are ignored.
