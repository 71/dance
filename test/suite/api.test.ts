/* eslint-disable require-await */
import * as vscode from "vscode";

import { expect, ExpectedDocument } from "./utils";
import { Context, deindentLines, edit, EmptySelectionsError, indentLines, insert, insertByIndex, isPosition, isRange, isSelection, joinLines, mapActive, mapBoth, mapEnd, mapStart, moveWhileBackward, moveWhileForward, moveWithBackward, moveWithForward, NotASelectionError, pipe, Positions, replace, replaceByIndex, rotate, rotateContents, rotateSelections, searchBackward, searchForward, Select, SelectionBehavior, Selections, text } from "../../src/api";
import { Extension } from "../../src/state/extension";

function setSelectionBehavior(selectionBehavior: SelectionBehavior) {
  Context.current.mode.update("_selectionBehavior", selectionBehavior);
}

function resetNormalMode(extension: Extension) {
  extension.modes.get("normal")?.update("_selectionBehavior", SelectionBehavior.Caret);
}

suite("API tests", function () {
  // Set up document.
  let document: vscode.TextDocument,
      editor: vscode.TextEditor,
      extension: Extension;
  const cancellationToken = new vscode.CancellationTokenSource().token;

  this.beforeAll(async () => {
    document = await vscode.workspace.openTextDocument();
    editor = await vscode.window.showTextDocument(document);
    editor.options.insertSpaces = true;
    editor.options.tabSize = 2;

    extension = (await vscode.extensions.getExtension("gregoire.dance")!.activate()).extension;
  });

  this.beforeEach(() => resetNormalMode(extension));

  this.afterAll(async () => {
    await vscode.commands.executeCommand("workbench.action.closeActiveEditor");
  });

  //
  // Content below this line was auto-generated by api.test.build.ts. Do not edit manually.

  suite("./src/api/context.ts", function () {

    test("function text", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo bar
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const start = new vscode.Position(0, 0),
              end = new vscode.Position(0, 3);

        expect(
          text(new vscode.Range(start, end)),
          "to be",
          "foo",
        );
      });

      // No expected end document.
    });

    test("function text#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo bar
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const start1 = new vscode.Position(0, 0),
              end1 = new vscode.Position(0, 3),
              start2 = new vscode.Position(0, 4),
              end2 = new vscode.Position(0, 7);

        expect(
          text([new vscode.Range(start1, end1), new vscode.Range(start2, end2)]),
          "to equal",
          ["foo", "bar"],
        );
      });

      // No expected end document.
    });

    test("function edit", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              hello world
              ^^^^^ 0
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              heo world
              ^^^ 0
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await edit((editBuilder) => {
          const start = new vscode.Position(0, 2),
                end = new vscode.Position(0, 4);

          editBuilder.delete(new vscode.Range(start, end));
        });
      });

      after.assertEquals(editor);
    });

    test("function selectionsToCharacterMode", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a
              b
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        // One-character selection becomes empty.
        expect(Selections.toCharacterMode([Selections.fromAnchorActive(0, 0, 0, 1)]), "to satisfy", [
          expect.it("to be empty at coords", 0, 0),
        ]);

        // One-character selection becomes empty (at line break).
        expect(Selections.toCharacterMode([Selections.fromAnchorActive(0, 1, 1, 0)]), "to satisfy", [
          expect.it("to be empty at coords", 0, 1),
        ]);

        // Forward-facing selection becomes shorter.
        expect(Selections.toCharacterMode([Selections.fromAnchorActive(0, 0, 1, 1)]), "to satisfy", [
          expect.it("to have anchor at coords", 0, 0).and("to have cursor at coords", 1, 0),
        ]);

        // One-character selection becomes empty (reversed).
        expect(Selections.toCharacterMode([Selections.fromAnchorActive(0, 1, 0, 0)]), "to satisfy", [
          expect.it("to be empty at coords", 0, 0),
        ]);

        // One-character selection becomes empty (reversed, at line break).
        expect(Selections.toCharacterMode([Selections.fromAnchorActive(1, 0, 0, 1)]), "to satisfy", [
          expect.it("to be empty at coords", 0, 1),
        ]);

        // Reversed selection stays as-is.
        expect(Selections.toCharacterMode([Selections.fromAnchorActive(1, 1, 0, 0)]), "to satisfy", [
          expect.it("to have anchor at coords", 1, 1).and("to have cursor at coords", 0, 0),
        ]);

        // Empty selection stays as-is.
        expect(Selections.toCharacterMode([Selections.empty(1, 1)]), "to satisfy", [
          expect.it("to be empty at coords", 1, 1),
        ]);
      });

      // No expected end document.
    });

    test("function selectionsFromCharacterMode", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.fromCharacterMode([Selections.empty(0, 0)]), "to satisfy", [
          expect.it("to be empty at coords", 0, 0),
        ]);
      });

      // No expected end document.
    });

    test("function selectionsFromCharacterMode#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a
              b

            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.fromCharacterMode([Selections.empty(0, 0)]), "to satisfy", [
          expect.it("to have anchor at coords", 0, 0).and("to have cursor at coords", 0, 1),
        ]);

        // At the end of the line, it selects the line ending:
        expect(Selections.fromCharacterMode([Selections.empty(0, 1)]), "to satisfy", [
          expect.it("to have anchor at coords", 0, 1).and("to have cursor at coords", 1, 0),
        ]);

        // But it does nothing at the end of the document:
        expect(Selections.fromCharacterMode([Selections.empty(2, 0)]), "to satisfy", [
          expect.it("to be empty at coords", 2, 0),
        ]);
      });

      // No expected end document.
    });

  });

  suite("./src/api/functional.ts", function () {

    test("function isPosition", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const position = new vscode.Position(0, 0),
              range = new vscode.Range(position, position),
              selection = new vscode.Selection(position, position);

        expect(isPosition(position), "to be true");
        expect(isPosition(range), "to be false");
        expect(isPosition(selection), "to be false");
      });

      // No expected end document.
    });

    test("function isRange", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const position = new vscode.Position(0, 0),
              range = new vscode.Range(position, position),
              selection = new vscode.Selection(position, position);

        expect(isRange(position), "to be false");
        expect(isRange(range), "to be true");
        expect(isRange(selection), "to be false");
      });

      // No expected end document.
    });

    test("function isSelection", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const position = new vscode.Position(0, 0),
              range = new vscode.Range(position, position),
              selection = new vscode.Selection(position, position);

        expect(isSelection(position) , "to be false");
        expect(isSelection(range)    , "to be false");
        expect(isSelection(selection), "to be true");
      });

      // No expected end document.
    });

    test("function mapStart", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const p1 = new vscode.Position(0, 0),
              p2 = new vscode.Position(0, 1);

        expect(
          mapStart(p1, (x) => x.translate(1)),
          "to equal",
          new vscode.Position(1, 0),
        );
        expect(
          mapStart(new vscode.Range(p1, p2), (x) => x.translate(1)),
          "to equal",
          new vscode.Range(p2, new vscode.Position(1, 0)),
        );
        expect(
          mapStart(new vscode.Selection(p1, p2), (x) => x.translate(1)),
          "to equal",
          new vscode.Selection(new vscode.Position(1, 0), p2),
        );
        expect(
          mapStart(new vscode.Selection(p2, p1), (x) => x.translate(1)),
          "to equal",
          new vscode.Selection(p2, new vscode.Position(1, 0)),
        );
      });

      // No expected end document.
    });

    test("function mapEnd", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const p1 = new vscode.Position(0, 0),
              p2 = new vscode.Position(0, 1);

        expect(
          mapEnd(p1, (x) => x.translate(1)),
          "to equal",
          new vscode.Position(1, 0),
        );
        expect(
          mapEnd(new vscode.Range(p1, p2), (x) => x.translate(1)),
          "to equal",
          new vscode.Range(p1, new vscode.Position(1, 1)),
        );
        expect(
          mapEnd(new vscode.Selection(p1, p2), (x) => x.translate(1)),
          "to equal",
          new vscode.Selection(p1, new vscode.Position(1, 1)),
        );
        expect(
          mapEnd(new vscode.Selection(p2, p1), (x) => x.translate(1)),
          "to equal",
          new vscode.Selection(new vscode.Position(1, 1), p1),
        );
      });

      // No expected end document.
    });

    test("function mapActive", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const p1 = new vscode.Position(0, 0),
              p2 = new vscode.Position(0, 1);

        expect(
          mapActive(p1, (x) => x.translate(1)),
          "to equal",
          new vscode.Position(1, 0),
        );
        expect(
          mapActive(new vscode.Selection(p1, p2), (x) => x.translate(1)),
          "to equal",
          new vscode.Selection(p1, new vscode.Position(1, 1)),
        );
      });

      // No expected end document.
    });

    test("function mapBoth", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const p1 = new vscode.Position(0, 0),
              p2 = new vscode.Position(0, 1);

        expect(
          mapBoth(p1, (x) => x.translate(1)),
          "to equal",
          new vscode.Position(1, 0),
        );
        expect(
          mapBoth(new vscode.Range(p1, p2), (x) => x.translate(1)),
          "to equal",
          new vscode.Range(new vscode.Position(1, 0), new vscode.Position(1, 1)),
        );
        expect(
          mapBoth(new vscode.Selection(p1, p2), (x) => x.translate(1)),
          "to equal",
          new vscode.Selection(new vscode.Position(1, 0), new vscode.Position(1, 1)),
        );
        expect(
          mapBoth(new vscode.Selection(p2, p1), (x) => x.translate(1)),
          "to equal",
          new vscode.Selection(new vscode.Position(1, 1), new vscode.Position(1, 0)),
        );
      });

      // No expected end document.
    });

    test("function pipe", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const doubleNumbers = pipe((n) => typeof n === "number" ? n : undefined,
                                   (n) => n * 2);

        expect(
          doubleNumbers([1, "a", 2, null, 3, {}]),
          "to equal",
          [2, 4, 6],
        );
      });

      // No expected end document.
    });

  });

  suite("./src/api/edit/index.ts", function () {

    test("function insert", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              1 2 3
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              2 4 6
              ^ 0
                ^ 1
                  ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(await insert(insert.Replace, (x) => `${+x * 2}`));
      });

      after.assertEquals(editor);
    });

    test("function insertByIndex", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              1a 2b 3c
               ^ 0
                  ^ 1
                     ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(await insertByIndex(insert.Start, (i) => `${i + 1}`));
      });

      after.assertEquals(editor);
    });

    test("function insertByIndex#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              1a 2b 3c
              ^ 0
                 ^ 1
                    ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(await insertByIndex(insert.Start | insert.Select, (i) => `${i + 1}`));
      });

      after.assertEquals(editor);
    });

    test("function insertByIndex#2", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              1a 2b 3c
              ^^ 0
                 ^^ 1
                    ^^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(await insertByIndex(insert.Start | insert.Extend, (i) => `${i + 1}`));
      });

      after.assertEquals(editor);
    });

    test("function insertByIndex#3", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a1 b2 c3
              ^ 0
                 ^ 1
                    ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(await insertByIndex(insert.End, (i) => `${i + 1}`));
      });

      after.assertEquals(editor);
    });

    test("function insertByIndex#4", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a1 b2 c3
               ^ 0
                  ^ 1
                     ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(await insertByIndex(insert.End | insert.Select, (i) => `${i + 1}`));
      });

      after.assertEquals(editor);
    });

    test("function insertByIndex#5", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a1 b2 c3
              ^^ 0
                 ^^ 1
                    ^^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(await insertByIndex(insert.End | insert.Extend, (i) => `${i + 1}`));
      });

      after.assertEquals(editor);
    });

    test("function replace", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              1 2 3
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              2 4 6
              ^ 0
                ^ 1
                  ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await replace((x) => `${+x * 2}`);
      });

      after.assertEquals(editor);
    });

    test("function replaceByIndex", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              1 2 3
              ^ 0
                ^ 1
                  ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await replaceByIndex((i) => `${i + 1}`);
      });

      after.assertEquals(editor);
    });

    test("function rotate", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              c a b
              ^ 2
                ^ 0
                  ^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await rotate(1);
      });

      after.assertEquals(editor);
    });

    test("function rotateContents", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              c a b
              ^ 0
                ^ 1
                  ^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await rotateContents(1);
      });

      after.assertEquals(editor);
    });

    test("function rotateSelections", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 0
                ^ 1
                  ^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a b c
              ^ 2
                ^ 0
                  ^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        rotateSelections(1);
      });

      after.assertEquals(editor);
    });

  });

  suite("./src/api/search/index.ts", function () {

    test("function searchBackward", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const [p1, [t1]] = searchBackward(/\w/, new vscode.Position(0, 1))!;

        expect(p1, "to be at coords", 0, 0);
        expect(t1, "to be", "a");

        const [p2, [t2]] = searchBackward(/\w/, new vscode.Position(0, 2))!;

        expect(p2, "to be at coords", 0, 1);
        expect(t2, "to be", "b");

        const [p3, [t3]] = searchBackward(/\w+/, new vscode.Position(0, 2))!;

        expect(p3, "to be at coords", 0, 0);
        expect(t3, "to be", "ab");

        expect(
          searchBackward(/\w/, new vscode.Position(0, 0)),
          "to be undefined",
        );
      });

      // No expected end document.
    });

    test("function searchForward", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const [p1, [t1]] = searchForward(/\w/, new vscode.Position(0, 0))!;

        expect(p1, "to be at coords", 0, 0);
        expect(t1, "to be", "a");

        const [p2, [t2]] = searchForward(/\w/, new vscode.Position(0, 1))!;

        expect(p2, "to be at coords", 0, 1);
        expect(t2, "to be", "b");

        const [p3, [t3]] = searchForward(/\w+/, new vscode.Position(0, 1))!;

        expect(p3, "to be at coords", 0, 1);
        expect(t3, "to be", "bc");

        expect(
          searchForward(/\w/, new vscode.Position(0, 3)),
          "to be undefined",
        );
      });

      // No expected end document.
    });

  });

  suite("./src/api/edit/linewise.ts", function () {

    test("function indentLines", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a

              c
              d
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
                a

              c
                d
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await indentLines([0, 1, 3]);
      });

      after.assertEquals(editor);
    });

    test("function indentLines#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
                  a
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await indentLines([0], 2);
      });

      after.assertEquals(editor);
    });

    test("function indentLines#2", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a

            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
                a
              ··
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await indentLines([0, 1], 1, true);
      });

      after.assertEquals(editor);
    });

    test("function deindentLines", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
                a
              ··
                  c
                  d
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a

                  c
                d
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await deindentLines([0, 1, 3]);
      });

      after.assertEquals(editor);
    });

    test("function deindentLines#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
                a
              ··
                  c
                  d
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a

                  c
              d
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await deindentLines([0, 1, 3], 2);
      });

      after.assertEquals(editor);
    });

    test("function joinLines", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b
              c d
              e f
              g h
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a b c d
              e f
              g h
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await joinLines([0]);
      });

      after.assertEquals(editor);
    });

    test("function joinLines#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b
              c d
              e f
              g h
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a b c d
              e f
              g h
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await joinLines([0, 1]);
      });

      after.assertEquals(editor);
    });

    test("function joinLines#2", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b
              c d
              e f
              g h
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a b c d
              e f g h
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await joinLines([0, 2]);
      });

      after.assertEquals(editor);
    });

    test("function joinLines#3", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a b
              c d
              e f
              g h
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              a b
              c d    e f
              g h
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        await joinLines([1], "    ");
      });

      after.assertEquals(editor);
    });

  });

  suite("./src/api/search/move.ts", function () {

    test("function moveWithBackward", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              1234578
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        // Go backward as long as the previous character is equal to the current
        // character minus one.
        expect(
          moveWithBackward((c, i) => +c === i - 1 ? +c : undefined,
                           9, new vscode.Position(0, 7)),
          "to be at coords", 0, 5,
        );
      });

      // No expected end document.
    });

    test("function moveWithForward", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              1234578
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(
          moveWithForward((c, i) => +c === i + 1 ? +c : undefined,
                          0, new vscode.Position(0, 0)),
          "to be at coords", 0, 5,
        );
      });

      // No expected end document.
    });

    test("function moveWhileBackward", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(
          moveWhileBackward((c) => /\w/.test(c), new vscode.Position(0, 3)),
          "to be at coords", 0, 0,
        );

        expect(
          moveWhileBackward((c) => c === "c", new vscode.Position(0, 3)),
          "to be at coords", 0, 2,
        );

        expect(
          moveWhileBackward((c) => c === "b", new vscode.Position(0, 3)),
          "to be at coords", 0, 3,
        );
      });

      // No expected end document.
    });

    test("function moveWhileForward", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(
          moveWhileForward((c) => /\w/.test(c), new vscode.Position(0, 0)),
          "to be at coords", 0, 3,
        );

        expect(
          moveWhileForward((c) => c === "a", new vscode.Position(0, 0)),
          "to be at coords", 0, 1,
        );

        expect(
          moveWhileForward((c) => c === "b", new vscode.Position(0, 0)),
          "to be at coords", 0, 0,
        );
      });

      // No expected end document.
    });

  });

  suite("./src/api/positions.ts", function () {

    test("function toString", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
              | 0
              def
                | 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Positions.toString(Selections.nth(0)!.active), "to be", "1:1");
        expect(Positions.toString(Selections.nth(1)!.active), "to be", "2:3");
      });

      // No expected end document.
    });

  });

  suite("./src/api/selections.ts", function () {

    test("function set", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              hello world
              ^ 0
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              hello world
                    ^^^^^ 0
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const start = new vscode.Position(0, 6),
              end = new vscode.Position(0, 11);

        Selections.set([new vscode.Selection(start, end)]);
      });

      after.assertEquals(editor);
    });

    test("function set#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        expect(() => Selections.set([]), "to throw an", EmptySelectionsError);
        expect(() => Selections.set([1 as any]), "to throw a", NotASelectionError);
      });

      // No expected end document.
    });

    test("function filter", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              ^^^ 0
                  ^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const atChar = (character: number) => new vscode.Position(0, character);

        expect(
          Selections.filter((text) => !isNaN(+text)),
          "to equal",
          [new vscode.Selection(atChar(4), atChar(7))],
        );
      });

      // No expected end document.
    });

    test("function filter#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              ^^^ 0
                  ^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const atChar = (character: number) => new vscode.Position(0, character);

        expect(
          await Selections.filter(async (text) => !isNaN(+text)),
          "to equal",
          [new vscode.Selection(atChar(4), atChar(7))],
        );
      });

      // No expected end document.
    });

    test("function map", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              ^^^ 0
                  ^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(
          Selections.map((text) => isNaN(+text) ? undefined : +text),
          "to equal",
          [123],
        );
      });

      // No expected end document.
    });

    test("function map#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              ^^^ 0
                  ^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(
          await Selections.map(async (text) => isNaN(+text) ? undefined : +text),
          "to equal",
          [123],
        );
      });

      // No expected end document.
    });

    test("function update", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              ^^^ 0
                  ^^^ 1
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              |^^ 0
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const reverseUnlessNumber = (text: string, sel: vscode.Selection) =>
          isNaN(+text) ? new vscode.Selection(sel.active, sel.anchor) : undefined;

        Selections.update(reverseUnlessNumber);
      });

      after.assertEquals(editor);
    });

    test("function update#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              ^^^ 0
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(() => Selections.update(() => undefined), "to throw an", EmptySelectionsError);
      });

      // No expected end document.
    });

    test("function update#2", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
              ^^^ 0
                  ^^^ 1
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              foo 123
                  |^^ 0
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        const reverseIfNumber = async (text: string, sel: vscode.Selection) =>
          !isNaN(+text) ? new vscode.Selection(sel.active, sel.anchor) : undefined;

        await Selections.update(reverseIfNumber);
      });

      after.assertEquals(editor);
    });

    test("function rotate", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo bar baz
              ^^^ 1   ^^^ 0
                  ^^^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              foo bar baz
              ^^^ 0   ^^^ 2
                  ^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(Selections.rotate(1));
      });

      after.assertEquals(editor);
    });

    test("function rotate#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              foo bar baz
              ^^^ 1   ^^^ 0
                  ^^^ 2
            `),
            after = ExpectedDocument.parseIndented(14, String.raw`
              foo bar baz
              ^^^ 2   ^^^ 1
                  ^^^ 0
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        Selections.set(Selections.rotate(-1));
      });

      after.assertEquals(editor);
    });

    test("function lines", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              ab
              ^^ 0
              cd
              ^ 1
              ef
              gh
              ^ 2
               ^ 3
              ij
              ^ 3
              kl
              | 4
              mn
               ^^ 5
              op
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.lines(), "to only contain", 0, 1, 3, 4, 5, 6);
      });

      // No expected end document.
    });

    test("function selectWithin", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              a1b2c3d4
              ^^^^^ 0
              e5f6g7h8
                ^^^^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.selectWithin(/\d/).map<string>(text), "to equal", [
          "1",
          "2",
          "6",
          "7",
          "8",
        ]);
      });

      // No expected end document.
    });

    test("function mergeOverlapping", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abcd
               ^^ 0
               ^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.mergeOverlapping(), "to equal", [Selections.nth(0)]);
      });

      // No expected end document.
    });

    test("function mergeOverlapping#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abcd
               | 0
               | 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.mergeOverlapping(), "to equal", [Selections.nth(0)]);
      });

      // No expected end document.
    });

    test("function mergeOverlapping#2", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abcd
              ^^^ 0
               ^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.mergeOverlapping(), "to satisfy", [
          expect.it("to start at coords", 0, 0).and("to end at coords", 0, 4),
        ]);
      });

      // No expected end document.
    });

    test("function mergeConsecutive", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abcd
              ^^ 0
                ^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.mergeOverlapping(), "to equal", Selections.current());

        expect(Selections.mergeConsecutive(), "to satisfy", [
          expect.it("to start at coords", 0, 0).and("to end at coords", 0, 4),
        ]);
      });

      // No expected end document.
    });

    test("function mergeConsecutive#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abcd
              ^^ 1
                ^^ 0
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.mergeOverlapping(), "to equal", Selections.current());

        expect(Selections.mergeConsecutive(), "to satisfy", [
          expect.it("to start at coords", 0, 0).and("to end at coords", 0, 4),
        ]);
      });

      // No expected end document.
    });

    test("function shift", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const s1 = Selections.empty(0, 0),
              shifted1 = Selections.shift(s1, Positions.at(0, 4), Select);

        expect(shifted1, "to have anchor at coords", 0, 0).and("to have cursor at coords", 0, 4);
      });

      // No expected end document.
    });

    test("function shift#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        setSelectionBehavior(SelectionBehavior.Character);
      });

      // No expected end document.
    });

    test("function isEntireLine", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
              ^^^^ 0

              def
              ^^^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.isEntireLine(Selections.nth(0)!), "to be true");
        expect(Selections.isEntireLine(Selections.nth(1)!), "to be false");
      });

      // No expected end document.
    });

    test("function isEntireLine#1", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
              ^^^^ 0
              def
              ^^^^ 0

            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.isEntireLine(Selections.nth(0)!), "to be false");
      });

      // No expected end document.
    });

    test("function isEntireLines", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
              ^^^^ 0
              def
              ^^^^ 0
              ghi
              ^^^^ 1
              jkl
              ^^^^ 2
              mno
              ^^^ 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.isEntireLines(Selections.nth(0)!), "to be true");
        expect(Selections.isEntireLines(Selections.nth(1)!), "to be true");
        expect(Selections.isEntireLines(Selections.nth(2)!), "to be false");
      });

      // No expected end document.
    });

    test("function startsWithEntireLine", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
                 ^ 0
              def
                ^^ 1
              ghi
              ^^^^ 1
              jkl
              mno
              ^^^^ 2
              pqr
              ^^ 2
              stu
              ^^^^ 3
              vwx
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.startsWithEntireLine(Selections.nth(0)!), "to be false");
        expect(Selections.startsWithEntireLine(Selections.nth(1)!), "to be false");
        expect(Selections.startsWithEntireLine(Selections.nth(2)!), "to be true");
        expect(Selections.startsWithEntireLine(Selections.nth(3)!), "to be true");
      });

      // No expected end document.
    });

    test("function endsWithEntireLine", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
                 ^ 0
              def
                ^^ 1
              ghi
              ^^^^ 1
              jkl
              mno
              ^^^^ 2
              pqr
              ^^ 2
              stu
              ^^^^ 3
              vwx
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.endsWithEntireLine(Selections.nth(0)!), "to be false");
        expect(Selections.endsWithEntireLine(Selections.nth(1)!), "to be true");
        expect(Selections.endsWithEntireLine(Selections.nth(2)!), "to be false");
        expect(Selections.endsWithEntireLine(Selections.nth(3)!), "to be true");
      });

      // No expected end document.
    });

    test("function text", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
              ^^^^ 0
              def
              ^^^ 0
              ghi
              ^ 1
                | 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.text(Selections.nth(0)!), "to be", "abc\ndef");
        expect(Selections.text(Selections.nth(1)!), "to be", "g");
        expect(Selections.text(Selections.nth(2)!), "to be", "");
      });

      // No expected end document.
    });

    test("function length", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
              ^^^^ 0
              def
              ^^^ 0
              ghi
              ^ 1
                | 2
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.length(Selections.nth(0)!), "to be", 7);
        expect(Selections.length(Selections.nth(1)!), "to be", 1);
        expect(Selections.length(Selections.nth(2)!), "to be", 0);
      });

      // No expected end document.
    });

    test("function toString", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken),
            before = ExpectedDocument.parseIndented(14, String.raw`
              abc
              ^^ 0
              def
               | 1
              ghi
                ^ 1
            `);

      await before.apply(editor);

      await context.runAsync(async () => {
        expect(Selections.toString(Selections.nth(0)!), "to be", "1:1 → 1:3");
        expect(Selections.toString(Selections.nth(1)!), "to be", "3:4 → 2:2");
      });

      // No expected end document.
    });

    test("function fromStartEnd", async function () {
      const editorState = extension.editors.getState(editor)!,
            context = new Context(editorState, cancellationToken);

      // No setup needed.

      await context.runAsync(async () => {
        const p0 = new vscode.Position(0, 0),
              p1 = new vscode.Position(0, 1);

        expect(Selections.fromStartEnd(p0, p1, false), "to satisfy", {
          start: p0,
          end: p1,
          anchor: p0,
          active: p1,
          isReversed: false,
        });

        expect(Selections.fromStartEnd(p0, p1, true), "to satisfy", {
          start: p0,
          end: p1,
          anchor: p1,
          active: p0,
          isReversed: true,
        });
      });

      // No expected end document.
    });

  });
});
