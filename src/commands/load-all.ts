import { CommandDescriptor, Commands } from ".";
import { ArgumentError, command, commands, Context, Direction, EditorRequiredError, Shift } from "../api";
import { Register } from "../state/registers";

function getRegister<F extends Register.Flags | Register.Flags[]>(
  _: Context.WithoutActiveEditor,
  argument: { register?: string | Register },
  defaultRegisterName: string,
  requiredFlags: F extends readonly (infer Fs)[] ? Fs : F,
): Register.WithFlags<F> {
  let register = argument.register;
  const extension = _.extension;

  if (typeof register === "string") {
    if (register.startsWith(" ")) {
      if (!(_ instanceof Context)) {
        throw new EditorRequiredError();
      }

      register = extension.registers.forDocument(_.document).get(register.slice(1));
    } else {
      register = extension.registers.get(register);
    }
  } else if (!(register instanceof Register)) {
    register = extension.registers.get(defaultRegisterName);
  }

  register.checkFlags(requiredFlags);

  return (argument.register = register as any);
}

function getCount(_: Context.WithoutActiveEditor, argument: { count?: number }) {
  const count = +(argument.count as any);

  if (count >= 0 && Number.isInteger(count)) {
    return count;
  }

  return (argument.count = 0);
}

function getRepetitions(_: Context.WithoutActiveEditor, argument: { count?: number }) {
  const count = getCount(_, argument);

  if (count <= 0) {
    return 1;
  }

  return count;
}

function getDirection(argument: { direction?: number | string }) {
  const direction = argument.direction;

  if (direction === undefined) {
    return undefined;
  }

  if (typeof direction === "number") {
    if (direction === 1 || direction === -1) {
      return direction as Direction;
    }
  } else if (typeof direction === "string") {
    if (direction === "forward") {
      return Direction.Forward;
    }

    if (direction === "backward") {
      return Direction.Backward;
    }
  }

  throw new ArgumentError(
    '"direction" must be "forward", "backward", 1, -1, or undefined',
    "direction",
  );
}

function getShift(argument: { shift?: number | string }) {
  const shift = argument.shift;

  if (shift === undefined) {
    return undefined;
  }

  if (typeof shift === "number") {
    if (shift === 0 || shift === 1 || shift === 2) {
      return shift as Shift;
    }
  } else if (typeof shift === "string") {
    if (shift === "jump") {
      return Shift.Jump;
    }

    if (shift === "select") {
      return Shift.Select;
    }

    if (shift === "extend") {
      return Shift.Extend;
    }
  }

  throw new ArgumentError(
    '"shift" must be "jump", "select", "extend", 0, 1, 2, or undefined',
    "shift",
  );
}

function getInput(argument: { input?: any }) {
  return argument.input;
}

function getSetInput(argument: { input?: any }) {
  return (input: unknown) => argument.input = input;
}

function getInputOr(argument: { input?: any }): any {
  const defaultInput = argument.input;

  if (defaultInput != null) {
    return () => defaultInput;
  }

  return (promptDefaultInput: () => any) => {
    const result = promptDefaultInput();

    if (typeof result.then === "function") {
      return (result as Thenable<any>).then((x) => (argument.input = x));
    }

    return (argument.input = result);
  };
}

function runCommands(
  arg: Record<string, any>,
  ...tuples: [id: string, arg?: Record<string, any>][]
) {
  const input = arg["input"];

  if (input !== undefined) {
    const firstTuple = tuples[0];

    if (firstTuple[1] === undefined) {
      firstTuple.push({ input });
    } else {
      firstTuple[1]["input"] ??= input;
    }

    delete arg["input"];
  }

  const lastTuple = tuples[tuples.length - 1];

  if (lastTuple[1] === undefined) {
    lastTuple.push(arg);
  } else {
    Object.assign(lastTuple[1], arg);
  }

  return commands(...tuples);
}

/* eslint-disable max-len */
/* eslint-disable no-useless-escape */

//
// Content below this line was auto-generated by load-all.build.ts. Do not edit manually.

/**
 * Loads the "dev" module and returns its defined commands.
 */
async function loadDevModule(): Promise<CommandDescriptor[]> {
  const {
    copyLastErrorMessage,
    setSelectionBehavior,
  } = await import("./dev");

  return [
    new CommandDescriptor(
      "dance.dev.copyLastErrorMessage",
      (_) => _.runAsync((_) => copyLastErrorMessage(_.extension)),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.dev.setSelectionBehavior",
      (_, argument) => _.runAsync((_) => setSelectionBehavior(_, _.extension, argument["mode"], argument["value"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
  ];
}

/**
 * Loads the "edit" module and returns its defined commands.
 */
async function loadEditModule(): Promise<CommandDescriptor[]> {
  const {
    align,
    case_swap,
    case_toLower,
    case_toUpper,
    copyIndentation,
    deindent,
    deindent_withIncomplete,
    indent,
    indent_withEmpty,
    insert,
    join,
    join_select,
    newLine_above,
    newLine_below,
    replaceCharacters,
  } = await import("./edit");

  return [
    new CommandDescriptor(
      "dance.edit.align",
      (_, argument) => _.runAsync((_) => align(_, _.selections, argument["fill"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.case.swap",
      (_) => _.runAsync((_) => case_swap(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.case.toLower",
      (_) => _.runAsync((_) => case_toLower(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.case.toUpper",
      (_) => _.runAsync((_) => case_toUpper(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.copyIndentation",
      (_, argument) => _.runAsync((_) => copyIndentation(_, _.document, _.selections, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.deindent",
      (_, argument) => _.runAsync((_) => deindent(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.deindent.withIncomplete",
      (_, argument) => _.runAsync((_) => deindent_withIncomplete(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.indent",
      (_, argument) => _.runAsync((_) => indent(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.indent.withEmpty",
      (_, argument) => _.runAsync((_) => indent_withEmpty(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.insert",
      (_, argument) => _.runAsync((_) => insert(_, _.selections, getRegister(_, argument, "dquote", Register.Flags.CanRead), argument["adjust"], argument["handleNewLine"], getRepetitions(_, argument), argument["select"], getShift(argument), argument["text"], argument["where"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.join",
      (_, argument) => _.runAsync((_) => join(_, argument["separator"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.join.select",
      (_, argument) => _.runAsync((_) => join_select(_, argument["separator"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.above",
      (_, argument) => _.runAsync((_) => newLine_above(_, getRepetitions(_, argument), argument["select"], getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.below",
      (_, argument) => _.runAsync((_) => newLine_below(_, getRepetitions(_, argument), argument["select"], getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.replaceCharacters",
      (_, argument) => _.runAsync((_) => replaceCharacters(_, getRepetitions(_, argument), getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.delete",
      (_, argument) => _.runAsync(() => runCommands(argument, [".edit.insert", { register: "_" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.delete-insert",
      (_, argument) => _.runAsync(() => runCommands(argument, [".modes.set", { input: "insert" }], [".edit.insert", { register: "_" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.above.insert",
      (_, argument) => _.runAsync(() => runCommands(argument, [".edit.newLine.above", { shift: "select" }], [".modes.insert.before"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.below.insert",
      (_, argument) => _.runAsync(() => runCommands(argument, [".edit.newLine.below", { shift: "select" }], [".modes.insert.before"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.after",
      (_, argument) => _.runAsync(() => runCommands(argument, [".edit.insert", { handleNewLine: true, where: "end" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.after.select",
      (_, argument) => _.runAsync(() => runCommands(argument, [".edit.insert", { handleNewLine: true, where: "end" , shift: "select" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.before",
      (_, argument) => _.runAsync(() => runCommands(argument, [".edit.insert", { handleNewLine: true, where: "start" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.before.select",
      (_, argument) => _.runAsync(() => runCommands(argument, [".edit.insert", { handleNewLine: true, where: "start", shift: "select" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.selectRegister-insert",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selectRegister"], [".edit.insert"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.yank-delete",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.saveText"], [".edit.insert", { register: "_" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.yank-delete-insert",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.saveText"], [".modes.set", { input: "insert" }], [".edit.insert", { register: "_" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.yank-replace",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.saveText", { register: "tmp" }], [".edit.insert"], [".updateRegister", { copyFrom: "tmp" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "history" module and returns its defined commands.
 */
async function loadHistoryModule(): Promise<CommandDescriptor[]> {
  const {
    recording_play,
    recording_start,
    recording_stop,
    redo,
    redo_selections,
    repeat,
    repeat_edit,
    undo,
    undo_selections,
  } = await import("./history");

  return [
    new CommandDescriptor(
      "dance.history.recording.play",
      (_, argument) => _.runAsync((_) => recording_play(_, getRepetitions(_, argument), getRegister(_, argument, "arobase", Register.Flags.CanReadWriteMacros))),
      CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.recording.start",
      (_, argument) => _.runAsync((_) => recording_start(_, getRegister(_, argument, "arobase", Register.Flags.CanReadWriteMacros))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.recording.stop",
      (_, argument) => _.runAsync((_) => recording_stop(_, getRegister(_, argument, "arobase", Register.Flags.CanReadWriteMacros))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.redo",
      (_) => _.runAsync((_) => redo()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.redo.selections",
      (_) => _.runAsync((_) => redo_selections()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.repeat",
      (_, argument) => _.runAsync((_) => repeat(_, getRepetitions(_, argument), argument["include"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.repeat.edit",
      (_, argument) => _.runAsync((_) => repeat_edit(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.undo",
      (_) => _.runAsync((_) => undo()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.undo.selections",
      (_) => _.runAsync((_) => undo_selections()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.repeat.seek",
      (_, argument) => _.runAsync(() => runCommands(argument, [".history.repeat", { include: "dance\\.seek\\..+" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.repeat.selection",
      (_, argument) => _.runAsync(() => runCommands(argument, [".history.repeat", { include: "dance\\.(seek|select|selections)\\..+" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "keybindings" module and returns its defined commands.
 */
async function loadKeybindingsModule(): Promise<CommandDescriptor[]> {
  const {
    setup,
  } = await import("./keybindings");

  return [
    new CommandDescriptor(
      "dance.keybindings.setup",
      (_, argument) => _.runAsync((_) => setup(_, getRegister(_, argument, "dquote", Register.Flags.CanWrite))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
  ];
}

/**
 * Loads the "misc" module and returns its defined commands.
 */
async function loadMiscModule(): Promise<CommandDescriptor[]> {
  const {
    cancel,
    changeInput,
    ignore,
    openMenu,
    run,
    selectRegister,
    updateCount,
    updateRegister,
  } = await import("./misc");

  return [
    new CommandDescriptor(
      "dance.cancel",
      (_) => _.runAsync((_) => cancel(_.extension)),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.changeInput",
      (_, argument) => _.runAsync((_) => changeInput(argument["action"])),
      CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.ignore",
      (_) => _.runAsync((_) => ignore()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.openMenu",
      (_, argument) => _.runAsync((_) => openMenu(_, getInputOr(argument), argument["menu"], argument["prefix"], argument["pass"], argument["locked"], argument["delay"], argument["title"])),
      CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.run",
      (_, argument) => _.runAsync((_) => run(_, getInput(argument), getInputOr(argument), getCount(_, argument), getRepetitions(_, argument), getRegister(_, argument, "null", Register.Flags.None), argument["commands"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selectRegister",
      (_, argument) => _.runAsync((_) => selectRegister(_, getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.updateCount",
      (_, argument) => _.runAsync((_) => updateCount(_, getCount(_, argument), _.extension, getInputOr(argument), argument["addDigits"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.updateRegister",
      (_, argument) => _.runAsync((_) => updateRegister(_, getRegister(_, argument, "dquote", Register.Flags.CanWrite), argument["copyFrom"], getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "modes" module and returns its defined commands.
 */
async function loadModesModule(): Promise<CommandDescriptor[]> {
  const {
    set,
    set_temporarily,
  } = await import("./modes");

  return [
    new CommandDescriptor(
      "dance.modes.set",
      (_, argument) => _.runAsync((_) => set(_, getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.temporarily",
      (_, argument) => _.runAsync((_) => set_temporarily(_, getInputOr(argument), getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.insert.after",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.faceForward" , { record: false }], [".modes.set", { input: "insert" }], [".selections.reduce", { where: "end" , record: false, empty: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.insert.before",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.faceBackward", { record: false }], [".modes.set", { input: "insert" }], [".selections.reduce", { where: "start", record: false, empty: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.insert.lineEnd",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineEnd" , { shift: "jump" }], [".modes.set", { input: "insert" }], [".selections.reduce", { where: "end" , record: false, empty: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.insert.lineStart",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineStart", { shift: "jump", skipBlank: true }], [".modes.set", { input: "insert" }], [".selections.reduce", { where: "start", record: false, empty: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.insert",
      (_, argument) => _.runAsync(() => runCommands(argument, [".modes.set", { input: "insert" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.normal",
      (_, argument) => _.runAsync(() => runCommands(argument, [".modes.set", { input: "normal" }], ["hideSuggestWidget"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.temporarily.insert",
      (_, argument) => _.runAsync(() => runCommands(argument, [".modes.set.temporarily", { input: "insert" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.temporarily.normal",
      (_, argument) => _.runAsync(() => runCommands(argument, [".modes.set.temporarily", { input: "normal" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "search" module and returns its defined commands.
 */
async function loadSearchModule(): Promise<CommandDescriptor[]> {
  const {
    next,
    search,
    selection,
  } = await import("./search");

  return [
    new CommandDescriptor(
      "dance.search",
      (_, argument) => _.runAsync((_) => search(_, getRegister<[Register.Flags.CanRead, Register.Flags.CanWrite]>(_, argument, "slash", Register.Flags.CanRead | Register.Flags.CanWrite), getRepetitions(_, argument), argument["add"], getDirection(argument), argument["interactive"], getShift(argument), getInput(argument), getSetInput(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.search.next",
      (_, argument) => _.runAsync((_) => next(_, _.document, getRegister(_, argument, "slash", Register.Flags.CanRead), getRepetitions(_, argument), argument["add"], getDirection(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.search.selection",
      (_, argument) => _.runAsync((_) => selection(_.document, _.selections, getRegister(_, argument, "slash", Register.Flags.CanWrite), argument["smart"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.search.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".search", { direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.backward.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".search", { direction: -1, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".search", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.next.add",
      (_, argument) => _.runAsync(() => runCommands(argument, [".search.next", { add: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.previous",
      (_, argument) => _.runAsync(() => runCommands(argument, [".search.next", { direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.previous.add",
      (_, argument) => _.runAsync(() => runCommands(argument, [".search.next", { direction: -1, add: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.selection.smart",
      (_, argument) => _.runAsync(() => runCommands(argument, [".search.selection", { smart: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "seek" module and returns its defined commands.
 */
async function loadSeekModule(): Promise<CommandDescriptor[]> {
  const {
    enclosing,
    object,
    seek,
    word,
  } = await import("./seek");

  return [
    new CommandDescriptor(
      "dance.seek",
      (_, argument) => _.runAsync((_) => seek(_, getInputOr(argument), getRepetitions(_, argument), getDirection(argument), getShift(argument), argument["include"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing",
      (_, argument) => _.runAsync((_) => enclosing(_, getDirection(argument), getShift(argument), argument["open"], argument["pairs"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.object",
      (_, argument) => _.runAsync((_) => object(_, getInputOr(argument), argument["inner"], argument["where"], getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.word",
      (_, argument) => _.runAsync((_) => word(_, getRepetitions(_, argument), argument["stopAtEnd"], argument["ws"], getDirection(argument), getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.askObject",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", title: "Select whole object..." }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.end",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ where: "end" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.end.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ where: "end" , shift: "extend" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ inner: true }], title: "Select inner object..." }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.end",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ inner: true, where: "end" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.end.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ inner: true, where: "end" , shift: "extend" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.start",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ inner: true, where: "start" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.start.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ inner: true, where: "start", shift: "extend" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.start",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ where: "start" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.start.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".openMenu", { input: "object", pass: [{ where: "start", shift: "extend" }] }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek", { direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.enclosing", { direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.enclosing", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing.extend.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.enclosing", { shift: "extend", direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.extend.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek", { shift: "extend", direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.included",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek", { include: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.included.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek", { include: true, direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.included.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek", { include: true, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.included.extend.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek", { include: true, shift: "extend", direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.extend.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { shift: "extend", direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { ws: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { ws: true, direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { ws: true, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws.extend.backward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { ws: true, shift: "extend", direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { stopAtEnd: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { stopAtEnd: true , shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd.ws",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { stopAtEnd: true , ws: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd.ws.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".seek.word", { stopAtEnd: true , ws: true, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "select" module and returns its defined commands.
 */
async function loadSelectModule(): Promise<CommandDescriptor[]> {
  const {
    buffer,
    firstVisibleLine,
    horizontally,
    lastLine,
    lastVisibleLine,
    lineEnd,
    lineStart,
    line_above,
    line_above_extend,
    line_below,
    line_below_extend,
    middleVisibleLine,
    to,
    vertically,
  } = await import("./select");

  return [
    new CommandDescriptor(
      "dance.select.buffer",
      (_) => _.runAsync((_) => buffer(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.firstVisibleLine",
      (_, argument) => _.runAsync((_) => firstVisibleLine(_, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.horizontally",
      (_, argument) => _.runAsync((_) => horizontally(_, argument["avoidEol"], getRepetitions(_, argument), getDirection(argument), getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lastLine",
      (_, argument) => _.runAsync((_) => lastLine(_, _.document, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lastVisibleLine",
      (_, argument) => _.runAsync((_) => lastVisibleLine(_, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.above",
      (_, argument) => _.runAsync((_) => line_above(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.above.extend",
      (_, argument) => _.runAsync((_) => line_above_extend(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.below",
      (_, argument) => _.runAsync((_) => line_below(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.below.extend",
      (_, argument) => _.runAsync((_) => line_below_extend(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lineEnd",
      (_, argument) => _.runAsync((_) => lineEnd(_, getCount(_, argument), getShift(argument), argument["lineBreak"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lineStart",
      (_, argument) => _.runAsync((_) => lineStart(_, getCount(_, argument), getShift(argument), argument["skipBlank"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.middleVisibleLine",
      (_, argument) => _.runAsync((_) => middleVisibleLine(_, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.to",
      (_, argument) => _.runAsync((_) => to(_, getCount(_, argument), argument, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.vertically",
      (_, argument) => _.runAsync((_) => vertically(_, _.selections, argument["avoidEol"], getRepetitions(_, argument), getDirection(argument), getShift(argument), argument["by"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.documentEnd.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineEnd", { count: 2147483647, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.documentEnd.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineEnd", { count: 2147483647, shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.down.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.vertically", { direction: 1, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.down.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.vertically", { direction: 1, shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstLine.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineStart", { count: 0, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstLine.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineStart", { count: 0, shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstVisibleLine.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.firstVisibleLine", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstVisibleLine.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.firstVisibleLine", { shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastLine.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lastLine", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastLine.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lastLine", { shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastVisibleLine.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lastVisibleLine", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastVisibleLine.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lastVisibleLine", { shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.left.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.horizontally", { direction: -1, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.left.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.horizontally", { direction: -1, shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineEnd.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineEnd", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineStart", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineStart", { shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.skipBlank.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineStart", { skipBlank: true, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.skipBlank.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.lineStart", { skipBlank: true, shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.middleVisibleLine.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.middleVisibleLine", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.middleVisibleLine.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.middleVisibleLine", { shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.right.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.horizontally", { direction: 1, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.right.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.horizontally", { direction: 1, shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.to.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.to", { shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.to.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.to", { shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.up.extend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.vertically", { direction: -1, shift: "extend" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.up.jump",
      (_, argument) => _.runAsync(() => runCommands(argument, [".select.vertically", { direction: -1, shift: "jump" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "selections" module and returns its defined commands.
 */
async function loadSelectionsModule(): Promise<CommandDescriptor[]> {
  const {
    changeDirection,
    copy,
    expandToLines,
    filter,
    merge,
    open,
    pipe,
    reduce,
    restore,
    restore_withCurrent,
    save,
    saveText,
    select,
    split,
    splitLines,
    toggleIndices,
    trimLines,
    trimWhitespace,
  } = await import("./selections");

  return [
    new CommandDescriptor(
      "dance.selections.changeDirection",
      (_, argument) => _.runAsync((_) => changeDirection(_, getDirection(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.copy",
      (_, argument) => _.runAsync((_) => copy(_, _.document, _.selections, getRepetitions(_, argument), getDirection(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.expandToLines",
      (_) => _.runAsync((_) => expandToLines(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.filter",
      (_, argument) => _.runAsync((_) => filter(_, getInput(argument), getSetInput(argument), argument["defaultInput"], argument["inverse"], argument["interactive"], getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.merge",
      (_) => _.runAsync((_) => merge(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.open",
      (_) => _.runAsync((_) => open(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.pipe",
      (_, argument) => _.runAsync((_) => pipe(_, getRegister(_, argument, "pipe", Register.Flags.CanWrite), getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.reduce",
      (_, argument) => _.runAsync((_) => reduce(_, argument["where"], argument["empty"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.restore",
      (_, argument) => _.runAsync((_) => restore(_, getRegister(_, argument, "caret", Register.Flags.CanReadSelections))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.restore.withCurrent",
      (_, argument) => _.runAsync((_) => restore_withCurrent(_, _.document, getRegister(_, argument, "caret", Register.Flags.CanReadSelections), argument["reverse"], argument["action"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.save",
      (_, argument) => _.runAsync((_) => save(_, _.document, _.selections, getRegister(_, argument, "caret", Register.Flags.CanWriteSelections), argument["style"], argument["until"], argument["untilDelay"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.saveText",
      (_, argument) => _.runAsync((_) => saveText(_.document, _.selections, getRegister(_, argument, "dquote", Register.Flags.CanWrite))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.select",
      (_, argument) => _.runAsync((_) => select(_, argument["interactive"], getInput(argument), getSetInput(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.split",
      (_, argument) => _.runAsync((_) => split(_, argument["excludeEmpty"], argument["interactive"], getInput(argument), getSetInput(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.splitLines",
      (_, argument) => _.runAsync((_) => splitLines(_, _.document, _.selections, getRepetitions(_, argument), argument["excludeEol"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.toggleIndices",
      (_, argument) => _.runAsync((_) => toggleIndices(_, argument["display"], argument["until"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.trimLines",
      (_) => _.runAsync((_) => trimLines(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.trimWhitespace",
      (_) => _.runAsync((_) => trimWhitespace(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.clear.main",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.filter", { input: "i !== count" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.clear.secondary",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.filter", { input: "i === count" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.copy.above",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.copy", { direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.faceBackward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.changeDirection", { direction: -1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.faceForward",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.changeDirection", { direction: 1 }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.filter.regexp",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.filter", { defaultInput: "/" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.filter.regexp.inverse",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.filter", { defaultInput: "/", inverse: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.hideIndices",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.toggleIndices", { display: false }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.pipe.append",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.pipe"], [".edit.insert", { register: "|", where: "end" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.pipe.prepend",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.pipe"], [".edit.insert", { register: "|", where: "start" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.pipe.replace",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.pipe"], [".edit.insert", { register: "|" }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.reduce.edges",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.reduce", { where: "both", empty: false }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.showIndices",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.toggleIndices", { display: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "selections.rotate" module and returns its defined commands.
 */
async function loadSelectionsRotateModule(): Promise<CommandDescriptor[]> {
  const {
    both,
    contents,
    selections,
  } = await import("./selections.rotate");

  return [
    new CommandDescriptor(
      "dance.selections.rotate.both",
      (_, argument) => _.runAsync((_) => both(_, getRepetitions(_, argument), argument["reverse"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.contents",
      (_, argument) => _.runAsync((_) => contents(_, getRepetitions(_, argument), argument["reverse"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.selections",
      (_, argument) => _.runAsync((_) => selections(_, getRepetitions(_, argument), argument["reverse"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.both.reverse",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.rotate.both", { reverse: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.contents.reverse",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.rotate.contents", { reverse: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.selections.reverse",
      (_, argument) => _.runAsync(() => runCommands(argument, [".selections.rotate.selections", { reverse: true }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "view" module and returns its defined commands.
 */
async function loadViewModule(): Promise<CommandDescriptor[]> {
  const {
    line,
  } = await import("./view");

  return [
    new CommandDescriptor(
      "dance.view.line",
      (_, argument) => _.runAsync((_) => line(_, argument["at"])),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
  ];
}

/**
 * Loads and returns all defined commands.
 */
export async function loadCommands(): Promise<Commands> {
  const allModules = await Promise.all([
    loadDevModule(),
    loadEditModule(),
    loadHistoryModule(),
    loadKeybindingsModule(),
    loadMiscModule(),
    loadModesModule(),
    loadSearchModule(),
    loadSeekModule(),
    loadSelectModule(),
    loadSelectionsModule(),
    loadSelectionsRotateModule(),
    loadViewModule(),
  ]);

  return Object.freeze(
    Object.fromEntries(allModules.flat().map((desc) => [desc.identifier, desc])),
  );
}
