import { ArgumentError, commands, Context, Direction, EditorRequiredError, Shift } from "../api";
import { Register } from "../state/registers";
import { CommandDescriptor, Commands } from ".";

function getRegister<F extends Register.Flags>(
  _: Context.WithoutActiveEditor,
  argument: { register?: string | Register },
  defaultRegisterName: string,
  requiredFlags: F,
): Register.WithFlags<F> {
  let register = argument.register;
  const extension = _.extension;

  if (typeof register === "string") {
    if (register.startsWith(" ")) {
      if (!(_ instanceof Context)) {
        throw new EditorRequiredError();
      }

      register = extension.registers.forDocument(_.document).get(register.slice(1));
    } else {
      register = extension.registers.get(register);
    }
  } else if (!(register instanceof Register)) {
    register = extension.registers.get(defaultRegisterName);
  }

  register.checkFlags(requiredFlags);

  return (argument.register = register as any);
}

function getCount(_: Context.WithoutActiveEditor, argument: { count?: number }) {
  const count = +(argument.count as any);

  if (count >= 0 && Number.isInteger(count)) {
    return count;
  }

  return (argument.count = 0);
}

function getRepetitions(_: Context.WithoutActiveEditor, argument: { count?: number }) {
  const count = getCount(_, argument);

  if (count <= 0) {
    return 1;
  }

  return count;
}

function getDirection(argument: { direction?: number | string }) {
  const direction = argument.direction;

  if (direction === undefined) {
    return undefined;
  }

  if (typeof direction === "number") {
    if (direction === 1 || direction === -1) {
      return direction as Direction;
    }
  } else if (typeof direction === "string") {
    if (direction === "forward") {
      return Direction.Forward;
    }

    if (direction === "backward") {
      return Direction.Backward;
    }
  }

  throw new ArgumentError(
    '"direction" must be "forward", "backward", 1, -1, or undefined',
    "direction",
  );
}

function getShift(argument: { shift?: number | string }) {
  const shift = argument.shift;

  if (shift === undefined) {
    return undefined;
  }

  if (typeof shift === "number") {
    if (shift === 0 || shift === 1 || shift === 2) {
      return shift as Shift;
    }
  } else if (typeof shift === "string") {
    if (shift === "jump") {
      return Shift.Jump;
    }

    if (shift === "select") {
      return Shift.Select;
    }

    if (shift === "extend") {
      return Shift.Extend;
    }
  }

  throw new ArgumentError(
    '"shift" must be "jump", "select", "extend", 0, 1, 2, or undefined',
    "shift",
  );
}

function getInput(argument: { input?: any }) {
  return argument.input;
}

function getSetInput(argument: { input?: any }) {
  return (input: unknown) => argument.input = input;
}

function getInputOr(argument: { input?: any }): any {
  const defaultInput = argument.input;

  if (defaultInput != null) {
    return () => defaultInput;
  }

  return (promptDefaultInput: () => any) => {
    const result = promptDefaultInput();

    if (typeof result.then === "function") {
      return (result as Thenable<any>).then((x) => (argument.input = x));
    }

    return (argument.input = result);
  };
}

/* eslint-disable max-len */

//
// Content below this line was auto-generated by load-all.build.ts. Do not edit manually.

/**
 * Loads the "edit" module and returns its defined commands.
 */
async function loadEditModule(): Promise<CommandDescriptor[]> {
  const {
    align,
    case_swap,
    case_toLower,
    case_toUpper,
    copyIndentation,
    deindent,
    deindent_withIncomplete,
    indent,
    indent_withEmpty,
    insert,
    join,
    join_select,
    newLine_above,
    newLine_below,
    replaceCharacters,
  } = await import("./edit");

  return [
    new CommandDescriptor(
      "dance.edit.align",
      (_, argument) => _.runAsync((_) => align(_, _.selections, argument.fill)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.case.swap",
      (_) => _.runAsync((_) => case_swap(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.case.toLower",
      (_) => _.runAsync((_) => case_toLower(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.case.toUpper",
      (_) => _.runAsync((_) => case_toUpper(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.copyIndentation",
      (_, argument) => _.runAsync((_) => copyIndentation(_, _.document, _.selections, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.deindent",
      (_, argument) => _.runAsync((_) => deindent(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.deindent.withIncomplete",
      (_, argument) => _.runAsync((_) => deindent_withIncomplete(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.indent",
      (_, argument) => _.runAsync((_) => indent(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.indent.withEmpty",
      (_, argument) => _.runAsync((_) => indent_withEmpty(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.insert",
      (_, argument) => _.runAsync((_) => insert(_, _.selections, getRegister(_, argument, "dquote", Register.Flags.CanRead), argument.adjust, argument.handleNewLine, argument.select, argument.where)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.join",
      (_, argument) => _.runAsync((_) => join(_, argument.separator)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.join.select",
      (_, argument) => _.runAsync((_) => join_select(_, argument.separator)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.above",
      (_, argument) => _.runAsync((_) => newLine_above(_, argument.select)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.below",
      (_, argument) => _.runAsync((_) => newLine_below(_, argument.select)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.replaceCharacters",
      (_, argument) => _.runAsync((_) => replaceCharacters(_, getRepetitions(_, argument), getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.edit.delete",
      (_, argument) => _.runAsync(() => commands([".edit.insert", { register: "_", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.delete-insert",
      (_, argument) => _.runAsync(() => commands([".modes.set", { input: "insert", ...argument }], [".edit.insert", { register: "_", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.above.insert",
      (_, argument) => _.runAsync(() => commands([".modes.set", { input: "insert", ...argument }], [".edit.newLine.above", { select: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.newLine.below.insert",
      (_, argument) => _.runAsync(() => commands([".modes.set", { input: "insert", ...argument }], [".edit.newLine.below", { select: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.after",
      (_, argument) => _.runAsync(() => commands([".edit.insert", { handleNewLine: true, where: "end", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.after.select",
      (_, argument) => _.runAsync(() => commands([".edit.insert", { handleNewLine: true, where: "end" , select: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.before",
      (_, argument) => _.runAsync(() => commands([".edit.insert", { handleNewLine: true, where: "start", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.paste.before.select",
      (_, argument) => _.runAsync(() => commands([".edit.insert", { handleNewLine: true, where: "start", select: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.selectRegister-insert",
      (_, argument) => _.runAsync(() => commands([".selectRegister"], [".edit.insert"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.yank-delete",
      (_, argument) => _.runAsync(() => commands([".selections.saveText"], [".edit.insert", { register: "_", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.yank-delete-insert",
      (_, argument) => _.runAsync(() => commands([".selections.saveText"], [".modes.set", { input: "insert", ...argument }], [".edit.insert", { register: "_", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.edit.yank-replace",
      (_, argument) => _.runAsync(() => commands([".selections.saveText"], [".edit.insert"])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "history" module and returns its defined commands.
 */
async function loadHistoryModule(): Promise<CommandDescriptor[]> {
  const {
    recording_play,
    recording_start,
    recording_stop,
    redo,
    redo_selections,
    repeat,
    repeat_edit,
    undo,
    undo_selections,
  } = await import("./history");

  return [
    new CommandDescriptor(
      "dance.history.recording.play",
      (_, argument) => _.runAsync((_) => recording_play(_, getRepetitions(_, argument), getRegister(_, argument, "arobase", Register.Flags.CanReadWriteMacros))),
      CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.recording.start",
      (_, argument) => _.runAsync((_) => recording_start(_, getRegister(_, argument, "arobase", Register.Flags.CanReadWriteMacros))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.recording.stop",
      (_, argument) => _.runAsync((_) => recording_stop(_, getRegister(_, argument, "arobase", Register.Flags.CanReadWriteMacros))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.redo",
      (_) => _.runAsync((_) => redo()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.redo.selections",
      (_) => _.runAsync((_) => redo_selections()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.repeat",
      (_, argument) => _.runAsync((_) => repeat(_, getRepetitions(_, argument), argument.include)),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.repeat.edit",
      (_, argument) => _.runAsync((_) => repeat_edit(_, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.undo",
      (_) => _.runAsync((_) => undo()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.undo.selections",
      (_) => _.runAsync((_) => undo_selections()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.history.repeat.objectSelection",
      (_, argument) => _.runAsync(() => commands([".history.repeat", { include: "dance\\.seek\\..+", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.history.repeat.selection",
      (_, argument) => _.runAsync(() => commands([".history.repeat", { include: "dance\\.(seek|select|selections)\\..+", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "keybindings" module and returns its defined commands.
 */
async function loadKeybindingsModule(): Promise<CommandDescriptor[]> {
  const {
    setup,
  } = await import("./keybindings");

  return [
    new CommandDescriptor(
      "dance.keybindings.setup",
      (_, argument) => _.runAsync((_) => setup(_, getRegister(_, argument, "dquote", Register.Flags.CanWrite))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
  ];
}

/**
 * Loads the "misc" module and returns its defined commands.
 */
async function loadMiscModule(): Promise<CommandDescriptor[]> {
  const {
    cancel,
    ignore,
    openMenu,
    run,
    selectRegister,
    updateCount,
  } = await import("./misc");

  return [
    new CommandDescriptor(
      "dance.cancel",
      (_) => _.runAsync((_) => cancel(_.extension)),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.ignore",
      (_) => _.runAsync((_) => ignore()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.openMenu",
      (_, argument) => _.runAsync((_) => openMenu(_, getInputOr(argument), argument.menu, argument.prefix, argument.pass)),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.run",
      (_, argument) => _.runAsync((_) => run(_, getInputOr(argument), argument.commands)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selectRegister",
      (_, argument) => _.runAsync((_) => selectRegister(_, getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.updateCount",
      (_, argument) => _.runAsync((_) => updateCount(_, getCount(_, argument), _.extension, getInputOr(argument), argument.addDigits)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
  ];
}

/**
 * Loads the "modes" module and returns its defined commands.
 */
async function loadModesModule(): Promise<CommandDescriptor[]> {
  const {
    set,
    set_temporarily,
  } = await import("./modes");

  return [
    new CommandDescriptor(
      "dance.modes.set",
      (_, argument) => _.runAsync((_) => set(_, getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.modes.set.temporarily",
      (_, argument) => _.runAsync((_) => set_temporarily(_, getInputOr(argument), getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.modes.insert.after",
      (_, argument) => _.runAsync(() => commands([".selections.faceForward"] , [".modes.set", { input: "insert", ...argument }], [".selections.reduce", { where: "end", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.insert.before",
      (_, argument) => _.runAsync(() => commands([".selections.faceBackward"], [".modes.set", { input: "insert", ...argument }], [".selections.reduce", { where: "start", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.insert.lineEnd",
      (_, argument) => _.runAsync(() => commands([".select.lineEnd" , { shift: "jump", ...argument }], [".modes.set", { input: "insert", ...argument }], [".selections.reduce", { where: "end", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.insert.lineStart",
      (_, argument) => _.runAsync(() => commands([".select.lineStart", { shift: "jump", skipBlank: true, ...argument }], [".modes.set", { input: "insert", ...argument }], [".selections.reduce", { where: "start", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.insert",
      (_, argument) => _.runAsync(() => commands([".modes.set", { input: "insert", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.normal",
      (_, argument) => _.runAsync(() => commands([".modes.set", { input: "normal", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.temporarily.insert",
      (_, argument) => _.runAsync(() => commands([".modes.set.temporarily", { input: "insert", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.modes.set.temporarily.normal",
      (_, argument) => _.runAsync(() => commands([".modes.set.temporarily", { input: "normal", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "search" module and returns its defined commands.
 */
async function loadSearchModule(): Promise<CommandDescriptor[]> {
  const {
    next,
    search,
    selection,
  } = await import("./search");

  return [
    new CommandDescriptor(
      "dance.search.",
      (_, argument) => _.runAsync((_) => search(_, getRegister(_, argument, "slash", Register.Flags.CanWrite), getRepetitions(_, argument), argument.add, getDirection(argument), argument.interactive, getInput(argument), getSetInput(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.search.next",
      (_, argument) => _.runAsync((_) => next(_, _.document, getRegister(_, argument, "slash", Register.Flags.CanRead), getRepetitions(_, argument), argument.add, getDirection(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.search.selection",
      (_, argument) => _.runAsync((_) => selection(_.document, _.selections, getRegister(_, argument, "slash", Register.Flags.CanWrite), argument.smart)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.search.add",
      (_, argument) => _.runAsync(() => commands([".search", { add: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.backward",
      (_, argument) => _.runAsync(() => commands([".search", { direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.backward.add",
      (_, argument) => _.runAsync(() => commands([".search", { direction: -1, add: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.next.add",
      (_, argument) => _.runAsync(() => commands([".search.next", { add: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.previous",
      (_, argument) => _.runAsync(() => commands([".search.next", { direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.previous.add",
      (_, argument) => _.runAsync(() => commands([".search.next", { direction: -1, add: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.search.selection.smart",
      (_, argument) => _.runAsync(() => commands([".search.selection", { smart: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "seek" module and returns its defined commands.
 */
async function loadSeekModule(): Promise<CommandDescriptor[]> {
  const {
    character,
    enclosing,
    object,
    word,
  } = await import("./seek");

  return [
    new CommandDescriptor(
      "dance.seek.character",
      (_, argument) => _.runAsync((_) => character(_, getInputOr(argument), getRepetitions(_, argument), getDirection(argument), getShift(argument), argument.include)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing",
      (_, argument) => _.runAsync((_) => enclosing(_, getDirection(argument), getShift(argument), argument.open, argument.pairs)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.object",
      (_, argument) => _.runAsync((_) => object(_, getInputOr(argument), argument.inner, argument.where, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.word",
      (_, argument) => _.runAsync((_) => word(_, getRepetitions(_, argument), argument.stopAtEnd, argument.ws, getDirection(argument), getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.seek.askObject",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.end",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ where: "end" , shift: "extend", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.end",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ where: "end", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ inner: true, ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.end",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ inner: true, where: "end", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.end.extend",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ inner: true, where: "end" , shift: "extend", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.start",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ inner: true, where: "start", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.inner.start.extend",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ inner: true, where: "start", shift: "extend", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.start",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ where: "start", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.askObject.start",
      (_, argument) => _.runAsync(() => commands([".openMenu", { input: "object", pass: [{ where: "start", shift: "extend", ...argument }], ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.character.backward",
      (_, argument) => _.runAsync(() => commands([".seek.character", { direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.character.extend",
      (_, argument) => _.runAsync(() => commands([".seek.character", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.character.extend.backward",
      (_, argument) => _.runAsync(() => commands([".seek.character", { shift: "extend", direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.character.included",
      (_, argument) => _.runAsync(() => commands([".seek.character", { include: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.character.included.backward",
      (_, argument) => _.runAsync(() => commands([".seek.character", { include: true, direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.character.included.extend",
      (_, argument) => _.runAsync(() => commands([".seek.character", { include: true, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.character.included.extend.backward",
      (_, argument) => _.runAsync(() => commands([".seek.character", { include: true, shift: "extend", direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing.backward",
      (_, argument) => _.runAsync(() => commands([".seek.enclosing", { direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing.extend",
      (_, argument) => _.runAsync(() => commands([".seek.enclosing", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.enclosing.extend.backward",
      (_, argument) => _.runAsync(() => commands([".seek.enclosing", { shift: "extend", direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.backward",
      (_, argument) => _.runAsync(() => commands([".seek.word", { direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.extend",
      (_, argument) => _.runAsync(() => commands([".seek.word", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.extend.backward",
      (_, argument) => _.runAsync(() => commands([".seek.word", { shift: "extend", direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws",
      (_, argument) => _.runAsync(() => commands([".seek.word", { ws: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws.backward",
      (_, argument) => _.runAsync(() => commands([".seek.word", { ws: true, direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws.extend",
      (_, argument) => _.runAsync(() => commands([".seek.word", { ws: true, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.word.ws.extend.backward",
      (_, argument) => _.runAsync(() => commands([".seek.word", { ws: true, shift: "extend", direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd",
      (_, argument) => _.runAsync(() => commands([".seek.word", { stopAtEnd: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd.extend",
      (_, argument) => _.runAsync(() => commands([".seek.word", { stopAtEnd: true , shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd.ws",
      (_, argument) => _.runAsync(() => commands([".seek.word", { stopAtEnd: true , ws: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.seek.wordEnd.ws.extend",
      (_, argument) => _.runAsync(() => commands([".seek.word", { stopAtEnd: true , ws: true, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "select" module and returns its defined commands.
 */
async function loadSelectModule(): Promise<CommandDescriptor[]> {
  const {
    buffer,
    firstVisibleLine,
    horizontally,
    lastLine,
    lastModification,
    lastVisibleLine,
    lineEnd,
    lineStart,
    line_above,
    line_above_extend,
    line_below,
    line_below_extend,
    middleVisibleLine,
    to,
    vertically,
  } = await import("./select");

  return [
    new CommandDescriptor(
      "dance.select.buffer",
      (_) => _.runAsync((_) => buffer(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.firstVisibleLine",
      (_, argument) => _.runAsync((_) => firstVisibleLine(_, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.horizontally",
      (_, argument) => _.runAsync((_) => horizontally(_, getRepetitions(_, argument), getDirection(argument), getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lastLine",
      (_, argument) => _.runAsync((_) => lastLine(_, _.document, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lastModification",
      (_, argument) => _.runAsync((_) => lastModification(_, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lastVisibleLine",
      (_, argument) => _.runAsync((_) => lastVisibleLine(_, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.above",
      (_, argument) => _.runAsync((_) => line_above(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.above.extend",
      (_, argument) => _.runAsync((_) => line_above_extend(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.below",
      (_, argument) => _.runAsync((_) => line_below(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.line.below.extend",
      (_, argument) => _.runAsync((_) => line_below_extend(_, getCount(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lineEnd",
      (_, argument) => _.runAsync((_) => lineEnd(_, getCount(_, argument), getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.lineStart",
      (_, argument) => _.runAsync((_) => lineStart(_, getCount(_, argument), getShift(argument), argument.skipBlank)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.middleVisibleLine",
      (_, argument) => _.runAsync((_) => middleVisibleLine(_, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.to",
      (_, argument) => _.runAsync((_) => to(_, getCount(_, argument), argument, getShift(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.vertically",
      (_, argument) => _.runAsync((_) => vertically(_, _.selections, getRepetitions(_, argument), getDirection(argument), getShift(argument), argument.by)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.select.documentEnd.extend",
      (_, argument) => _.runAsync(() => commands([".select.lineEnd", { count: 2147483647, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.documentEnd.jump",
      (_, argument) => _.runAsync(() => commands([".select.lineEnd", { count: 2147483647, shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.down.extend",
      (_, argument) => _.runAsync(() => commands([".select.vertically", { direction: 1, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.down.jump",
      (_, argument) => _.runAsync(() => commands([".select.vertically", { direction: 1, shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstLine.extend",
      (_, argument) => _.runAsync(() => commands([".select.lineStart", { count: 0, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstLine.jump",
      (_, argument) => _.runAsync(() => commands([".select.lineStart", { count: 0, shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstVisibleLine.extend",
      (_, argument) => _.runAsync(() => commands([".select.firstVisibleLine", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.firstVisibleLine.jump",
      (_, argument) => _.runAsync(() => commands([".select.firstVisibleLine", { shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastLine.extend",
      (_, argument) => _.runAsync(() => commands([".select.lastLine", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastLine.jump",
      (_, argument) => _.runAsync(() => commands([".select.lastLine", { shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastModification.extend",
      (_, argument) => _.runAsync(() => commands([".select.lastModification", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastModification.jump",
      (_, argument) => _.runAsync(() => commands([".select.lastModification", { shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastVisibleLine.extend",
      (_, argument) => _.runAsync(() => commands([".select.lastVisibleLine", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lastVisibleLine.jump",
      (_, argument) => _.runAsync(() => commands([".select.lastVisibleLine", { shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.left.extend",
      (_, argument) => _.runAsync(() => commands([".select.horizontally", { direction: -1, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.left.jump",
      (_, argument) => _.runAsync(() => commands([".select.horizontally", { direction: -1, shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineEnd.extend",
      (_, argument) => _.runAsync(() => commands([".select.lineEnd", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.extend",
      (_, argument) => _.runAsync(() => commands([".select.lineStart", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.jump",
      (_, argument) => _.runAsync(() => commands([".select.lineStart", { shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.skipBlank.extend",
      (_, argument) => _.runAsync(() => commands([".select.lineStart", { skipBlank: true, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.lineStart.skipBlank.jump",
      (_, argument) => _.runAsync(() => commands([".select.lineStart", { skipBlank: true, shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.middleVisibleLine.extend",
      (_, argument) => _.runAsync(() => commands([".select.middleVisibleLine", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.middleVisibleLine.jump",
      (_, argument) => _.runAsync(() => commands([".select.middleVisibleLine", { shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.right.extend",
      (_, argument) => _.runAsync(() => commands([".select.horizontally", { direction: 1, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.right.jump",
      (_, argument) => _.runAsync(() => commands([".select.horizontally", { direction: 1, shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.to.extend",
      (_, argument) => _.runAsync(() => commands([".select.to", { shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.to.jump",
      (_, argument) => _.runAsync(() => commands([".select.to", { shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.up.extend",
      (_, argument) => _.runAsync(() => commands([".select.vertically", { direction: -1, shift: "extend", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.select.up.jump",
      (_, argument) => _.runAsync(() => commands([".select.vertically", { direction: -1, shift: "jump", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "selections" module and returns its defined commands.
 */
async function loadSelectionsModule(): Promise<CommandDescriptor[]> {
  const {
    changeDirection,
    copy,
    extendToLines,
    filter,
    merge,
    open,
    pipe,
    reduce,
    restore,
    restore_withCurrent,
    save,
    saveText,
    select,
    split,
    splitLines,
    toggleIndices,
    trimLines,
    trimWhitespace,
  } = await import("./selections");

  return [
    new CommandDescriptor(
      "dance.selections.changeDirection",
      (_, argument) => _.runAsync((_) => changeDirection(_, getDirection(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.copy",
      (_, argument) => _.runAsync((_) => copy(_, _.document, _.selections, getRepetitions(_, argument), getDirection(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.extendToLines",
      (_) => _.runAsync((_) => extendToLines(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.filter",
      (_, argument) => _.runAsync((_) => filter(_, getInput(argument), getSetInput(argument), argument.defaultInput, argument.inverse, argument.interactive)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.merge",
      (_) => _.runAsync((_) => merge()),
      CommandDescriptor.Flags.None,
    ),
    new CommandDescriptor(
      "dance.selections.open",
      (_) => _.runAsync((_) => open(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.pipe",
      (_, argument) => _.runAsync((_) => pipe(_, getRegister(_, argument, "pipe", Register.Flags.CanWrite), getInputOr(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.reduce",
      (_, argument) => _.runAsync((_) => reduce(_, argument.where)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.restore",
      (_, argument) => _.runAsync((_) => restore(_, getRegister(_, argument, "caret", Register.Flags.CanReadSelections))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.restore.withCurrent",
      (_, argument) => _.runAsync((_) => restore_withCurrent(_, _.document, getRegister(_, argument, "caret", Register.Flags.CanReadSelections), argument.reverse)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.save",
      (_, argument) => _.runAsync((_) => save(_, _.document, _.selections, getRegister(_, argument, "caret", Register.Flags.CanWriteSelections), argument.style, argument.until)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.saveText",
      (_, argument) => _.runAsync((_) => saveText(_.document, _.selections, getRegister(_, argument, "dquote", Register.Flags.CanWrite))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.select",
      (_, argument) => _.runAsync((_) => select(_, argument.interactive, getInput(argument), getSetInput(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.split",
      (_, argument) => _.runAsync((_) => split(_, argument.excludeEmpty, argument.interactive, getInput(argument), getSetInput(argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.splitLines",
      (_, argument) => _.runAsync((_) => splitLines(_, _.document, _.selections, getRepetitions(_, argument))),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.toggleIndices",
      (_, argument) => _.runAsync((_) => toggleIndices(_, argument.display, argument.until)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.trimLines",
      (_) => _.runAsync((_) => trimLines(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.trimWhitespace",
      (_) => _.runAsync((_) => trimWhitespace(_)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.clear.main",
      (_, argument) => _.runAsync(() => commands([".selections.filter", { input: "i !== 0", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.clear.secondary",
      (_, argument) => _.runAsync(() => commands([".selections.filter", { input: "i === 0", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.copy.above",
      (_, argument) => _.runAsync(() => commands([".selections.copy", { direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.faceBackward",
      (_, argument) => _.runAsync(() => commands([".selections.changeDirection", { direction: -1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.faceForward",
      (_, argument) => _.runAsync(() => commands([".selections.changeDirection", { direction: 1, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.filter.regexp",
      (_, argument) => _.runAsync(() => commands([".selections.filter", { defaultInput: "/", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.filter.regexp.inverse",
      (_, argument) => _.runAsync(() => commands([".selections.filter", { defaultInput: "/", inverse: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.hideIndices",
      (_, argument) => _.runAsync(() => commands([".selections.toggleIndices", { display: false, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.pipe.append",
      (_, argument) => _.runAsync(() => commands([".selections.pipe"], [".edit.insert", { register: "|", where: "end", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.pipe.prepend",
      (_, argument) => _.runAsync(() => commands([".selections.pipe"], [".edit.insert", { register: "|", where: "start", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.pipe.replace",
      (_, argument) => _.runAsync(() => commands([".selections.pipe"], [".edit.insert", { register: "|", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.reduce.edges",
      (_, argument) => _.runAsync(() => commands([".selections.reduce", { where: "both", ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.showIndices",
      (_, argument) => _.runAsync(() => commands([".selections.toggleIndices", { display: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads the "selections.rotate" module and returns its defined commands.
 */
async function loadSelectionsRotateModule(): Promise<CommandDescriptor[]> {
  const {
    both,
    contents,
    selections,
  } = await import("./selections.rotate");

  return [
    new CommandDescriptor(
      "dance.selections.rotate.both",
      (_, argument) => _.runAsync((_) => both(_, getRepetitions(_, argument), argument.reverse)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.contents",
      (_, argument) => _.runAsync((_) => contents(_, getRepetitions(_, argument), argument.reverse)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.selections",
      (_, argument) => _.runAsync((_) => selections(_, getRepetitions(_, argument), argument.reverse)),
      CommandDescriptor.Flags.RequiresActiveEditor,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.both.reverse",
      (_, argument) => _.runAsync(() => commands([".selections.rotate", { reverse: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.contents.reverse",
      (_, argument) => _.runAsync(() => commands([".selections.rotate.contents", { reverse: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
    new CommandDescriptor(
      "dance.selections.rotate.selections.reverse",
      (_, argument) => _.runAsync(() => commands([".selections.rotate.selections", { reverse: true, ...argument }])),
      CommandDescriptor.Flags.RequiresActiveEditor | CommandDescriptor.Flags.DoNotReplay,
    ),
  ];
}

/**
 * Loads and returns all defined commands.
 */
export async function loadCommands(): Promise<Commands> {
  const allModules = await Promise.all([
    loadEditModule(),
    loadHistoryModule(),
    loadKeybindingsModule(),
    loadMiscModule(),
    loadModesModule(),
    loadSearchModule(),
    loadSeekModule(),
    loadSelectModule(),
    loadSelectionsModule(),
    loadSelectionsRotateModule(),
  ]);

  return Object.freeze(
    Object.fromEntries(allModules.flat().map((desc) => [desc.identifier, desc])),
  );
}
