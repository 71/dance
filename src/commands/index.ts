// Auto-generated by src/build.ts. Do not edit manually.
/* eslint-disable max-len */

import { commands, Context } from "../api";
import { CommandContext } from "../command";

/**
 * Loads the "edit" module and returns its defined functions.
 */
async function loadEditModule() {
  const {
    join,
    join_select,
    indent,
    indent_withEmpty,
    deindent,
    deindent_withIncomplete,
    case_toLower,
    case_toUpper,
    case_swap,
    replaceCharacters,
    align,
    copyIndentation,
    insert,
    newLine_above,
    newLine_below,
  } = await import("./edit");

  return [
    ["edit.join", (_: CommandContext, ctx: Context) => ctx.run((ctx) => join(ctx, _.argument as any))] as const,
    ["edit.join.select", (_: CommandContext, ctx: Context) => ctx.run((ctx) => join_select(ctx, _.argument as any))] as const,
    ["edit.indent", (_: CommandContext, ctx: Context) => ctx.run((ctx) => indent(ctx, _.repetitions))] as const,
    ["edit.indent.withEmpty", (_: CommandContext, ctx: Context) => ctx.run((ctx) => indent_withEmpty(ctx, _.repetitions))] as const,
    ["edit.deindent", (_: CommandContext, ctx: Context) => ctx.run((ctx) => deindent(ctx, _.repetitions))] as const,
    ["edit.deindent.withIncomplete", (_: CommandContext, ctx: Context) => ctx.run((ctx) => deindent_withIncomplete(ctx, _.repetitions))] as const,
    ["edit.case.toLower", (ctx: Context) => ctx.run((ctx) => case_toLower(ctx))] as const,
    ["edit.case.toUpper", (ctx: Context) => ctx.run((ctx) => case_toUpper(ctx))] as const,
    ["edit.case.swap", (ctx: Context) => ctx.run((ctx) => case_swap(ctx))] as const,
    ["edit.replaceCharacters", (_: CommandContext, ctx: Context) => ctx.run((ctx) => replaceCharacters(ctx, _.repetitions, (_.argument as any)?.input))] as const,
    ["edit.align", (ctx: Context) => ctx.run((ctx) => align(ctx, ctx.selections))] as const,
    ["edit.copyIndentation", (_: CommandContext, ctx: Context) => ctx.run((ctx) => copyIndentation(ctx, ctx.editor, _.count))] as const,
    ["edit.insert", (_: CommandContext, ctx: Context) => ctx.run((ctx) => insert(ctx, _.cancellationToken, _.argument as any, _.register))] as const,
    ["edit.newLine.above", (_: CommandContext, ctx: Context) => ctx.run((ctx) => newLine_above(ctx, _.argument as any))] as const,
    ["edit.newLine.below", (_: CommandContext, ctx: Context) => ctx.run((ctx) => newLine_below(ctx, _.argument as any))] as const,
    ["edit.pipe.filter", (ctx: Context) => ctx.run(() => commands())] as const,
    ["edit.pipe.replace", (ctx: Context) => ctx.run(() => commands())] as const,
    ["edit.pipe.append", (ctx: Context) => ctx.run(() => commands())] as const,
    ["edit.pipe.prepend", (ctx: Context) => ctx.run(() => commands())] as const,
    ["edit.newLine.above.insert", (ctx: Context) => ctx.run(() => commands([".newLine.above", { "switchToMode": "insert" }]))] as const,
    ["edit.newLine.below.insert", (ctx: Context) => ctx.run(() => commands([".newLine.below", { "switchToMode": "insert" }]))] as const,
  ];
}

/**
 * Loads the "misc" module and returns its defined functions.
 */
async function loadMiscModule() {
  const {
    toggle,
    cancel,
    selectRegister,
    updateCount,
    run,
  } = await import("./misc");

  return [
    ["toggle", (_: CommandContext) => toggle(_.extensionState)] as const,
    ["cancel", (_: CommandContext) => cancel(_)] as const,
    ["selectRegister", (_: CommandContext) => selectRegister(_.extensionState, _.cancellationToken, (_.argument as any)?.input)] as const,
    ["updateCount", (_: CommandContext) => updateCount(_.extensionState, _.cancellationToken, _.argument as any, (_.argument as any)?.input)] as const,
    ["run", (_: CommandContext, ctx: Context) => run(ctx, _.argument as any, (_.argument as any)?.input)] as const,
  ];
}

/**
 * Loads the "modes" module and returns its defined functions.
 */
async function loadModesModule() {
  const {
    set,
    set_temporarily,
  } = await import("./modes");

  return [
    ["modes.set", (_: CommandContext, ctx: Context) => ctx.run((ctx) => set(ctx, _.cancellationToken, (_.argument as any)?.input))] as const,
    ["modes.set.temporarily", (_: CommandContext, ctx: Context) => ctx.run((ctx) => set_temporarily(ctx, _.cancellationToken, (_.argument as any)?.input, _.repetitions))] as const,
    ["modes.set.normal", (ctx: Context) => ctx.run(() => commands([".modes.set", { "input": "normal" }]))] as const,
    ["modes.set.insert", (ctx: Context) => ctx.run(() => commands([".modes.set", { "input": "insert" }]))] as const,
    ["modes.set.temporarily.normal", (ctx: Context) => ctx.run(() => commands([".modes.set.temporarily", { "input": "normal" }]))] as const,
    ["modes.set.temporarily.insert", (ctx: Context) => ctx.run(() => commands([".modes.set.temporarily", { "input": "insert" }]))] as const,
  ];
}

/**
 * Loads the "selections" module and returns its defined functions.
 */
async function loadSelectionsModule() {
  const {
    save,
    restore,
    restore_withCurrent,
    pipe,
    extendToLines,
    trimLines,
    trimWhitespace,
    filter,
  } = await import("./selections");

  return [
    ["selections.save", (_: CommandContext, ctx: Context) => save(ctx.editor, _.extensionState, _.register?.withFlags(Register.Flags.CanReadSelections))] as const,
    ["selections.restore", (_: CommandContext, ctx: Context) => restore(ctx.editor, _.extensionState, _.register?.withFlags(Register.Flags.CanReadSelections))] as const,
    ["selections.restore.withCurrent", (_: CommandContext, ctx: Context) => restore_withCurrent(ctx.editor, _.extensionState, _.cancellationToken, _.register?.withFlags(Register.Flags.CanReadSelections), _.argument as any)] as const,
    ["selections.pipe", (_: CommandContext, ctx: Context) => ctx.run((ctx) => pipe(ctx, _.extensionState, _.cancellationToken, _.register?.withFlags(Register.Flags.CanWrite), (_.argument as any)?.input))] as const,
    ["selections.extendToLines", (ctx: Context) => ctx.run((ctx) => extendToLines(ctx))] as const,
    ["selections.trimLines", (ctx: Context) => ctx.run((ctx) => trimLines(ctx))] as const,
    ["selections.trimWhitespace", (ctx: Context) => ctx.run((ctx) => trimWhitespace(ctx))] as const,
    ["selections.filter", (_: CommandContext, ctx: Context) => ctx.run((ctx) => filter(ctx, _.cancellationToken, _.argument as any, (_.argument as any)?.input))] as const,
    ["selections.pipe.replace", (ctx: Context) => ctx.run(() => commands([".selections.pipe"], [".edit.insert", { "register": "|" }]))] as const,
    ["selections.pipe.append", (ctx: Context) => ctx.run(() => commands([".selections.pipe"], [".edit.insert", { "register": "|", "where": "end" }]))] as const,
    ["selections.pipe.prepend", (ctx: Context) => ctx.run(() => commands([".selections.pipe"], [".edit.insert", { "register": "|", "where": "start" }]))] as const,
    ["selections.filter.regexp", (ctx: Context) => ctx.run(() => commands([".selections.filter", { "defaultInput": "/" }]))] as const,
  ];
}

/**
 * Loads the "selections.rotate" module and returns its defined functions.
 */
async function loadSelections.rotateModule() {
  const {
    both,
    contents,
    selections,
  } = await import("./selections.rotate");

  return [
    ["selections.rotate.both", (_: CommandContext, ctx: Context) => ctx.run((ctx) => both(ctx, _.repetitions, _.argument as any))] as const,
    ["selections.rotate.contents", (_: CommandContext, ctx: Context) => ctx.run((ctx) => contents(ctx, _.repetitions, _.argument as any))] as const,
    ["selections.rotate.selections", (_: CommandContext, ctx: Context) => ctx.run((ctx) => selections(ctx, _.repetitions, _.argument as any))] as const,
    ["selections.rotate.both.reverse", (ctx: Context) => ctx.run(() => commands([".selections.rotate", { "reverse": true }]))] as const,
    ["selections.rotate.contents.reverse", (ctx: Context) => ctx.run(() => commands([".selections.rotate.contents", { "reverse": true }]))] as const,
    ["selections.rotate.selections.reverse", (ctx: Context) => ctx.run(() => commands([".selections.rotate.selections", { "reverse": true }]))] as const,
  ];
}

/**
 * Loads all defined commands and returns an array of `[functionName,
 * functionImplementation]` pairs.
 */
export async function loadCommands() {
  const perModuleFunctions = await Promise.all([
    loadEditModule(),
    loadMiscModule(),
    loadModesModule(),
    loadSelectionsModule(),
    loadSelections.rotateModule(),
  ]);

  return perModuleFunctions.flat(1);
}
